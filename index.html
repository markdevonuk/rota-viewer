<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Event Rota Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
<style>
body { padding: 1rem; background-color: #f9f9f9; }
h2 { 
  font-size: 1.8rem; 
  font-weight: bold; 
  margin-bottom: 0;
  text-transform: none !important; /* Force no text transformation */
  -webkit-text-transform: none !important; /* For Safari */
  text-decoration: none !important;
  font-variant: normal !important;
  letter-spacing: normal !important;
}
/* More aggressive override to ensure title displays consistently */
h2#pageTitle,
#pageTitle {
  text-transform: none !important;
  -webkit-text-transform: none !important;
  letter-spacing: normal !important;
  font-variant: normal !important;
  text-decoration: none !important;
  -webkit-font-smoothing: antialiased !important;
  font-style: normal !important;
}
/* Even more specific targeting for mobile */
.container .d-flex h2#pageTitle {
  text-transform: none !important;
  -webkit-text-transform: none !important;
}
/* More aggressive Bootstrap override */
.h2, h2 {
  text-transform: none !important;
  -webkit-text-transform: none !important;
}
.shift-header { margin-top: 3rem; text-align: center; }
.section-header { margin-top: 2rem; font-size: 1.5rem; font-weight: bold; }
.card { 
  border-radius: 0.75rem; 
  display: flex;
  flex-direction: column;
}
.badge-early { background-color: #0d6efd; color: #fff; font-size: 1rem; }
.badge-late { background-color: #6f42c1; color: #fff; font-size: 1rem; }
.badge-night { background-color: #212529; color: #fff; font-size: 1rem; }
.card-leadership { background-color: #e7f3ff; }
.card-vehicles { background-color: #f0f0f0; }
.card-responders { background-color: #e8fbe8; }
.card-static { background-color: #ffe4e1; }
.card-stage { background-color: #f0e8ff; }
.card-medcomms { background-color: #fff8e7; }
.card-makeready { background-color: #ffffe0; }
.card-dtl {
  border: 3px solid #186638 !important;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
  transform: translateY(-2px);
}
.spinner { display: flex; justify-content: center; padding: 2rem; }
.header-row { align-items: center; margin-bottom: 1rem; }
.shift-links { margin: 1rem 0; }
.search-icon { cursor: pointer; font-size: 1.5rem; }
.search-modal {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 300px;
  background: white;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  display: none;
  z-index: 1000;
}
.search-modal.active {
  display: block;
}
.search-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.2);
  display: none;
  z-index: 999;
}
.search-backdrop.active {
  display: block;
}
.search-results-header {
  background-color: #f8f9fa;
  padding: 1rem;
  border-radius: 8px;
  margin-bottom: 1.5rem;
  font-size: 1.2rem;
  font-weight: bold;
}
  .search-modal {
  z-index: 2000; /* raised */
}

.search-backdrop {
  z-index: 999; /* stays lower */
}

.initial-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  color: #666;
}
.back-to-top {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 40px;
  height: 40px;
  background-color: #0d6efd;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
  z-index: 998;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
.back-to-top:hover {
  background-color: #0b5ed7;
}
.back-to-top.visible {
  opacity: 1;
  visibility: visible;
}
html {
  scroll-behavior: smooth;
}
.day-navigation {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.day-navigation button {
  padding: 0.25rem 0.5rem;
}
.card-content {
  flex: 1;
}
.copyright {
  text-align: center;
  color: #6c757d;
  font-size: 0.9rem;
  margin-top: 3rem;
  margin-bottom: 2rem;
  padding-top: 1rem;
  border-top: 1px solid #dee2e6;
}
/* Mobile-specific override */
@media (max-width: 768px) {
  .day-navigation {
    display: flex;
    flex-direction: row;
    width: 100%;
    justify-content: center;
  }
  #daySelect {
    max-width: 200px;
  }
  /* Ensure title styling is consistent on mobile */
  h2, h2#pageTitle, #pageTitle, .h2 {
    text-transform: none !important;
    -webkit-text-transform: none !important;
    letter-spacing: normal !important;
    font-variant: normal !important;
    text-decoration: none !important;
  }
}
/* Touch and swipe styles */
.swipe-container {
  touch-action: pan-y;
  user-select: none;
}
  
  .header-logo {
  height: 50px;
  width: auto;
  margin-right: 10px;
}
</style>
</head>
<body>
<!-- Header Row with Logo, Title and Search Icon -->
<div class="d-flex justify-content-between align-items-center mb-3">
  <div class="d-flex align-items-center">
    <img src="fms.png" alt="FMS" class="header-logo me-3">
    <h2 id="pageTitle">Event Rota</h2>
  </div>
  <i class="bi bi-search search-icon" onclick="toggleSearch()"></i>
</div>
  
  <!-- Day Selector with Navigation -->
  <div class="day-navigation mb-4">
    <button class="btn btn-outline-primary" onclick="navigateDay(-1)">
      <i class="bi bi-chevron-left"></i>
    </button>
    <select id="daySelect" class="form-select" onchange="loadRota()" disabled>
      <option>Loading days...</option>
    </select>
    <button class="btn btn-outline-primary" onclick="navigateDay(1)">
      <i class="bi bi-chevron-right"></i>
    </button>
  </div>
  
  <!-- Jump Links (shown conditionally) -->
  <div id="shiftLinks" class="shift-links text-center">
    <a href="#early" class="me-2">Early</a> |
    <a href="#late" class="mx-2">Late</a> |
    <a href="#night" class="ms-2">Night</a>
  </div>
  
  <div id="rotaContent" class="swipe-container">
    <div class="initial-loading">
      <div class="spinner-border text-primary mb-3" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div>Loading rota data...</div>
    </div>
  </div>
  
  <div class="mt-5 text-center">
    <button class="btn btn-outline-secondary me-2" onclick="forceReloadRota()">Reload Rota</button>
    <button class="btn btn-danger" onclick="clearRotaCache()">Clear Cache</button>
    <div id="dataStatus" class="mt-2" style="font-size: 0.9rem; color: gray;"></div>
    <div id="lastRefresh" class="mt-1" style="font-size: 0.8rem; color: #6c757d;"></div>
  </div>
  
  <!-- Copyright Notice -->
  <div class="copyright">
    © <span id="currentYear"></span> Mark Walker. All rights reserved.
  </div>
</div>

<!-- Back to Top Button -->
<div class="back-to-top" onclick="scrollToTop()" title="Back to top">
  <i class="bi bi-arrow-up"></i>
</div>

<!-- Search Modal -->
<div class="search-backdrop" onclick="toggleSearch()"></div>
<div class="search-modal">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h5 class="mb-0">Search Crew</h5>
    <i class="bi bi-x-lg" style="cursor: pointer;" onclick="toggleSearch()"></i>
  </div>
  <div class="input-group">
    <input type="text" id="searchInput" class="form-control" placeholder="Enter name..." onkeypress="handleSearchKeyPress(event)">
    <button class="btn btn-primary" onclick="runSearch()">
      <i class="bi bi-search"></i>
    </button>
  </div>
</div>


<script>
// Config
const API_URL = "https://script.google.com/macros/s/AKfycbxUX2Atntw4DthlFARM0IxSOlo1ETMQhZep2ag88IxA5Xcf6Q6hV1HqCBD278s-0phOsQ/exec";

let rotaCache = [];
let availableDays = [];
let autoRefreshTimer = null;
let isSearchMode = false;
let currentSearchTerm = "";
let touchStartX = 0;
let touchEndX = 0;
let touchStartTime = 0;
let currentEvent = "";
const AUTO_REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds

// Get event from URL parameter
function getEventFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('event') || 'Glastonbury2025'; // Default to Glastonbury if no parameter
}

// Format event name for display
function formatEventName(eventCode) {
    // Convert "Glastonbury2025" to "Glastonbury 2025"
    return eventCode.replace(/(\d{4})$/, ' $1');
}

// Update page title and header
function updatePageHeader(eventName) {
    const formattedName = formatEventName(eventName);
    document.title = `${formattedName} Rota`;
    document.getElementById('pageTitle').textContent = `${formattedName} Rota`;
    
    // Additional fix for mobile browsers
    const titleElement = document.getElementById('pageTitle');
    titleElement.style.textTransform = 'none';
    titleElement.style.webkitTextTransform = 'none';
    titleElement.style.letterSpacing = 'normal';
    titleElement.style.fontVariant = 'normal';
}

// Set current year in copyright notice
function setCurrentYear() {
    document.getElementById('currentYear').textContent = new Date().getFullYear();
}

// Format time to ensure 2-digit hours
function formatTime(timeString) {
    if (!timeString) return timeString;
    
    // Split the time range into start and end times
    const times = timeString.split('-');
    
    // Format each time part
    const formattedTimes = times.map(time => {
        const trimmedTime = time.trim();
        
        // Check if it's already in the correct format
        if (/^\d{2}:\d{2}$/.test(trimmedTime)) {
            return trimmedTime;
        }
        
        // If it's in format like "7:00", add leading zero
        if (/^\d:\d{2}$/.test(trimmedTime)) {
            return '0' + trimmedTime;
        }
        
        return trimmedTime;
    });
    
    // Join the formatted times back together
    return formattedTimes.join(' - ');
}

function normalizeDay(dayValue) {
    if (!dayValue) return "";
    const clean = dayValue.trim().toLowerCase();
    const daysOfWeek = ["Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Monday"];
    for (const day of daysOfWeek) {
        if (clean.includes(day.toLowerCase())) return day;
    }
    return "";
}

function getShiftType(shiftTitle) {
    const clean = (shiftTitle || "").toLowerCase();
    if (clean.includes("early")) return "Early";
    if (clean.includes("late")) return "Late";
    if (clean.includes("night")) return "Night";
    return "Other";
}

function getBadgeClass(shiftType) {
    if (shiftType === "Early") return "badge-early";
    if (shiftType === "Late") return "badge-late";
    if (shiftType === "Night") return "badge-night";
    return "bg-secondary";
}

function getSectionFromRole(role) {
    const clean = role.trim().toLowerCase();
    if (["duty team leader", "charlie 1", "support"].includes(clean)) return "Leadership";
    if (/^(alpha|whisky|lima)/i.test(role)) return "Vehicles";
    if (/^romeo/i.test(role)) return "Responders";
    if (/^(mike gate|white medical|white alpha|blue medical|worthy view)/i.test(role)) return "Static Medical Points";
    if (/^stages/i.test(role)) return "Stage Medical";
    if (/^medcomms/i.test(role)) return "Medcomms Team";
    if (/^make/i.test(role)) return "Make Ready Team";
    return "General";
}

function getCardClass(section, role) {
    // Check if this is a Duty Team Leader card
    if (role && role.trim().toLowerCase() === "duty team leader") {
        return "card-leadership card-dtl";
    }
    
    const clean = section.toLowerCase();
    if (clean.includes("leadership")) return "card-leadership";
    if (clean.includes("vehicles")) return "card-vehicles";
    if (clean.includes("responders")) return "card-responders";
    if (clean.includes("static")) return "card-static";
    if (clean.includes("stage")) return "card-stage";
    if (clean.includes("medcomms")) return "card-medcomms";
    if (clean.includes("make ready")) return "card-makeready";
    return "";
}

// Caching Functions
function saveCacheToStorage() {
    // Use event-specific cache key
    const cacheKey = `rotaCache_${currentEvent}`;
    const timestampKey = `rotaCacheTimestamp_${currentEvent}`;
    
    localStorage.setItem(cacheKey, JSON.stringify(rotaCache));
    localStorage.setItem(timestampKey, Date.now());
    updateLastRefreshTime();
}

function loadCacheFromStorage() {
    // Use event-specific cache key
    const cacheKey = `rotaCache_${currentEvent}`;
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
        updateLastRefreshTime();
        try {
            return JSON.parse(cached);
        } catch (e) {
            console.error("Error parsing cached data:", e);
            return [];
        }
    }
    return [];
}

function isCacheStale(minutes = 15) {
    // Use event-specific timestamp key
    const timestampKey = `rotaCacheTimestamp_${currentEvent}`;
    const lastUpdate = parseInt(localStorage.getItem(timestampKey) || "0");
    return (Date.now() - lastUpdate) > minutes * 60 * 1000;
}

function updateLastRefreshTime() {
    // Use event-specific timestamp key
    const timestampKey = `rotaCacheTimestamp_${currentEvent}`;
    const timestamp = localStorage.getItem(timestampKey);
    if (timestamp) {
        const date = new Date(parseInt(timestamp));
        const timeString = date.toLocaleTimeString();
        document.getElementById("lastRefresh").textContent = `Last refreshed: ${timeString}`;
    }
}

function updateJumpLinksVisibility() {
    const shiftLinks = document.getElementById("shiftLinks");
    shiftLinks.style.display = isSearchMode ? "none" : "block";
}

function setupTouchHandlers() {
    const rotaContent = document.getElementById('rotaContent');
    
    // Add global click handler for search name items
    document.addEventListener('click', function(event) {
        const nameItem = event.target.closest('.search-name-item');
        if (nameItem) {
            event.preventDefault();
            event.stopPropagation();
            
            const name = nameItem.getAttribute('data-name') || 
                         nameItem.textContent.trim().split('\n')[0];
            handleNameSelection(name);
        }
    }, true);

    // Tracking variables for touch interactions
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isScrolling = false;
    let touchStartTime = 0;

    rotaContent.addEventListener('touchstart', (event) => {
        // Prevent interference with clickable elements
        const targetElement = event.target;
        if (targetElement.closest('.search-name-item, a, button')) {
            return;
        }

        // Record initial touch coordinates
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
        isScrolling = false;
        touchStartTime = Date.now();
    }, { passive: true });
    
    rotaContent.addEventListener('touchmove', (event) => {
        // Determine if this is a scroll or potential swipe
        touchEndX = event.touches[0].clientX;
        touchEndY = event.touches[0].clientY;
        
        const deltaX = Math.abs(touchEndX - touchStartX);
        const deltaY = Math.abs(touchEndY - touchStartY);
        
        // If vertical movement is significant, it's a scroll
        if (deltaY > deltaX && deltaY > 10) {
            isScrolling = true;
        }
        
        // If it's a near-horizontal movement and not on a clickable element, prevent default
        const targetElement = event.target;
        if (!isScrolling && 
            !targetElement.closest('.search-name-item, a, button') && 
            deltaX > deltaY && 
            deltaX > 50) {
            event.preventDefault();
        }
    }, { passive: false });
    
    rotaContent.addEventListener('touchend', (event) => {
        // Prevent interference with clickable elements
        const targetElement = event.target;
        if (targetElement.closest('.search-name-item, a, button')) {
            return;
        }

        // Check for swipe if not scrolling
        if (!isScrolling) {
            const deltaX = touchEndX - touchStartX;
            const swipeDuration = Date.now() - touchStartTime;
            
            // Swipe detection with duration check
            if (Math.abs(deltaX) > 100 && swipeDuration < 500) {
                if (deltaX > 0) {
                    navigateDay(-1); // Swipe right, go to previous day
                } else {
                    navigateDay(1);  // Swipe left, go to next day
                }
            }
        }
        
        // Reset tracking
        touchStartX = 0;
        touchStartY = 0;
        touchEndX = 0;
        touchEndY = 0;
        isScrolling = false;
        touchStartTime = 0;
    }, { passive: true });
}

// Search Function
function runSearch() {
    const query = document.getElementById("searchInput").value.trim().toLowerCase();
    if (!query) return alert("Please enter a name to search.");
    
    isSearchMode = true;
    currentSearchTerm = query;
    updateJumpLinksVisibility();
    toggleSearch(); // Close the search modal
    
    const matches = [];
    const foundNames = new Set();
    
    rotaCache.forEach(entry => {
        if (entry.crew1.toLowerCase().includes(query)) 
            foundNames.add(entry.crew1.trim());
        if (entry.crew2.toLowerCase().includes(query)) 
            foundNames.add(entry.crew2.trim());
        
        if (entry.crew1.toLowerCase().includes(query) || 
            entry.crew2.toLowerCase().includes(query)) {
            matches.push(entry);
        }
    });
    
    const uniqueNames = Array.from(foundNames);
    
    if (!matches.length) {
        document.getElementById("rotaContent").innerHTML = `
        <div class="search-results-header">Search results for "${query}"</div>
        <p class="text-center mt-4">No shifts found for that name.</p>
        `;
    } else if (uniqueNames.length > 1) {
        // Completely redesigned name selection with explicit handlers
        const nameList = uniqueNames.map(name => `
        <div class="list-group-item list-group-item-action p-3 mb-2 search-name-item" 
             onclick="handleNameSelection('${name.replace(/'/g, "\\'")}')"
             role="button" tabindex="0">
            <div class="d-flex w-100 justify-content-between align-items-center">
                <h5 class="mb-1">${name}</h5>
                <span class="badge bg-primary rounded-pill">
                ${matches.filter(m => 
                    m.crew1.trim().toLowerCase() === name.trim().toLowerCase() || 
                    m.crew2.trim().toLowerCase() === name.trim().toLowerCase()).length} 
                shifts
                </span>
            </div>
        </div>
        `).join("");
        
        document.getElementById("rotaContent").innerHTML = `
        <div class="search-results-header">Search results for "${query}"</div>
        <div class="container mt-4">
            <div class="list-group">
                ${nameList}
            </div>
        </div>
        `;
    } else {
        handleNameSelection(uniqueNames[0], query);
    }
}

// Name Selection Handler
// Modify name selection to handle both click and touch
function handleNameSelection(name, originalSearch = "") {
    // Prevent any potential touch/swipe interference
    touchStartX = 0;
    touchEndX = 0;
    
    // Ensure search mode is active
    isSearchMode = true;
    
    // Slight delay to ensure clean touch interaction
    setTimeout(() => {
        const results = rotaCache.filter(entry => 
            entry.crew1.trim().toLowerCase() === name.trim().toLowerCase() || 
            entry.crew2.trim().toLowerCase() === name.trim().toLowerCase()
        );
        renderGroupedRota(results, true, name);
    }, 50);
}

// Keep for backwards compatibility
function safeFilterByExactName(name, originalSearch = "") {
    return handleNameSelection(name, originalSearch);
}

// Toggle Search Modal
function toggleSearch() {
    const modal = document.querySelector('.search-modal');
    const backdrop = document.querySelector('.search-backdrop');
    const isActive = modal.classList.contains('active');
    
    if (isActive) {
        modal.classList.remove('active');
        backdrop.classList.remove('active');
    } else {
        modal.classList.add('active');
        backdrop.classList.add('active');
        document.getElementById('searchInput').focus();
    }
}

function handleSearchKeyPress(event) {
    if (event.key === 'Enter') {
        runSearch();
    }
}
  // Remaining Functions
async function preloadShifts(force = false) {
    // Show loading state
    document.getElementById("rotaContent").innerHTML = `
    <div class="initial-loading">
        <div class="spinner-border text-primary mb-3" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <div>Loading rota data...</div>
    </div>
    `;
    
    rotaCache = loadCacheFromStorage();
    const usingCache = !force && rotaCache.length > 0 && !isCacheStale(15);
    
    if (usingCache) {
        // Validate cached data before using it
        if (rotaCache.every(entry => entry.day && entry.role)) {
            updateAvailableDays();
            updateStatus("Loaded from cache");
            document.getElementById("daySelect").disabled = false;
            // Wait for next tick before loading rota to ensure UI is ready
            setTimeout(() => loadRota(), 0);
            return;
        } else {
            console.log("Cached data is invalid, fetching fresh data");
            rotaCache = [];
        }
    }
    
    try {
        updateStatus("Loading fresh data...");
        const res = await fetch(`${API_URL}?action=loadAllShifts&event=${currentEvent}`);
        const rawData = await res.json();
        
        if (rawData.error) {
            // Display more detailed error information
            let errorMessage = rawData.error;
            if (rawData.availableSheets) {
                errorMessage += "\nAvailable sheets: " + rawData.availableSheets.join(", ");
            }
            throw new Error(errorMessage);
        }
        
        if (!Array.isArray(rawData) || rawData.length === 0) {
            throw new Error("No data received from server");
        }
        
        rotaCache = rawData
            .filter(entry => entry["Location"] && entry["Day"]) // Filter out empty rows
            .map(entry => ({
                shiftTitle: (entry["Section"] || "").trim(),
                role: (entry["Location"] || "").trim(),
                // Format the time to ensure 2-digit hours
                time: formatTime(`${entry["Start"]} - ${entry["Finish"]}`),
                crew1: (entry["Crew 1"] || "").trim(),
                crew2: (entry["Crew 2"] || "").trim(),
                day: normalizeDay(entry["Day"])
            }))
            .filter(entry => entry.day && entry.role); // Double-check after mapping
        
        if (rotaCache.length === 0) {
            throw new Error("No valid shift data found");
        }
        
        saveCacheToStorage();
        updateAvailableDays();
        updateStatus("Live rota loaded");
        document.getElementById("daySelect").disabled = false;
        
        // Load the initial view
        setTimeout(() => loadRota(), 0);
    } catch (err) {
        console.error("Error loading rota data:", err);
        updateStatus("Error: " + err.message);
        document.getElementById("rotaContent").innerHTML = `
        <div class="alert alert-danger">
            <h4>Error Loading Data</h4>
            <p>${err.message}</p>
            <button class="btn btn-primary mt-3" onclick="forceReloadRota()">Try Again</button>
        </div>
        `;
        document.getElementById("daySelect").disabled = true;
    }
}

function updateAvailableDays() {
    const daysFound = new Set(rotaCache.map(entry => entry.day));
    availableDays = Array.from(daysFound)
        .filter(day => day) // Remove any empty days
        .sort((a, b) => {
            const dayOrder = ["Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Monday"];
            return dayOrder.indexOf(a) - dayOrder.indexOf(b);
        });
    
    const daySelect = document.getElementById("daySelect");
    if (availableDays.length === 0) {
        daySelect.innerHTML = '<option>No days available</option>';
        daySelect.disabled = true;
        return;
    }
    
    daySelect.innerHTML = availableDays.map(day => `<option value="${day}">${day}</option>`).join("");
    daySelect.disabled = false;
    
    // Check for saved day, if none saved or saved day not available, default to first day
    const savedDayKey = `selectedDay_${currentEvent}`;
    const savedDay = localStorage.getItem(savedDayKey);
    if (savedDay && availableDays.includes(savedDay)) {
        daySelect.value = savedDay;
    } else if (availableDays.length > 0) {
        // Default to the first available day
        daySelect.value = availableDays[0];
        localStorage.setItem(savedDayKey, availableDays[0]);
    }
}

function updateStatus(msg) {
    document.getElementById("dataStatus").textContent = msg;
}

function loadRota() {
    // Don't try to load if there's no data
    if (!rotaCache || rotaCache.length === 0) {
        console.log("No rota data available");
        return;
    }
    
    isSearchMode = false;
    updateJumpLinksVisibility();
    
    const daySelect = document.getElementById("daySelect");
    const day = daySelect.value;
    
    if (!day || day === "No days available") {
        document.getElementById("rotaContent").innerHTML = "<p>No day selected.</p>";
        return;
    }
    
    const savedDayKey = `selectedDay_${currentEvent}`;
    localStorage.setItem(savedDayKey, day);
    
    document.getElementById("rotaContent").innerHTML = 
    '<div class="spinner"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></div>';
    
    const dayData = rotaCache.filter(entry => entry.day.toLowerCase() === day.toLowerCase());
    
    // Small delay to ensure the spinner is visible
    setTimeout(() => {
        renderGroupedRota(dayData, false);
    }, 100);
}

function renderGroupedRota(data, isSearch = false, searchTerm = "") {
    if (!data || !data.length) {
        document.getElementById("rotaContent").innerHTML = "<p>No shifts found for this day.</p>";
        return;
    }
    
    if (isSearch) {
        let html = '';
        
        // Add search results header
        if (searchTerm) {
            html += `<div class="search-results-header">Search results for "${searchTerm}"</div>`;
        }
        
        const groupedByDay = {};
        data.forEach(entry => {
            if (!groupedByDay[entry.day]) groupedByDay[entry.day] = [];
            groupedByDay[entry.day].push(entry);
        });
        
        for (const day in groupedByDay) {
            html += `<h4 class="mt-4">${day}</h4><div class="row g-3 mb-4">`;
            groupedByDay[day].forEach(row => {
                html += `
                <div class="col-12 col-md-6">
                    <div class="card shadow-sm p-3 ${getCardClass(getSectionFromRole(row.role), row.role)}">
                        <div class="card-content">
                            <h5>${row.role}</h5>
                            <p><strong>Time:</strong> ${row.time}</p>
                            <p><strong>Crew 1:</strong> ${row.crew1 || "–"}</p>
                            <p><strong>Crew 2:</strong> ${row.crew2 || "–"}</p>
                        </div>
                    </div>
                </div>
                `;
            });
            html += `</div>`;
        }
        document.getElementById("rotaContent").innerHTML = html;
        return;
    }
    
    const groupedByShift = { Early: [], Late: [], Night: [], Other: [] };
    data.forEach(entry => 
        groupedByShift[getShiftType(entry.shiftTitle)].push(entry));
    
    let html = "";
    for (const shiftType of ["Early", "Late", "Night", "Other"]) {
        if (!groupedByShift[shiftType].length) continue;
        
        const selectedDay = document.getElementById("daySelect")?.value || "";
        html += `
        <div id="${shiftType.toLowerCase()}" class="shift-header my-5">
            <span class="badge ${getBadgeClass(shiftType)} p-2">${selectedDay} ${shiftType} Shifts</span>
        </div>
        `;
        
        const groupedBySection = {};
        groupedByShift[shiftType].forEach(entry => {
            const section = getSectionFromRole(entry.role);
            if (!groupedBySection[section]) groupedBySection[section] = [];
            groupedBySection[section].push(entry);
        });
        
        for (const section in groupedBySection) {
            html += `<div class="section-header">${section}</div><div class="row g-3 mb-4">`;
            html += groupedBySection[section].map(row => `
                <div class="col-12 col-md-6">
                    <div class="card shadow-sm p-3 ${getCardClass(section, row.role)}">
                        <div class="card-content">
                            <h5>${row.role}</h5>
                            <p><strong>Time:</strong> ${row.time}</p>
                            <p><strong>Crew 1:</strong> ${row.crew1 || "–"}</p>
                            <p><strong>Crew 2:</strong> ${row.crew2 || "–"}</p>
                        </div>
                    </div>
                </div>
            `).join("");
            html += `</div>`;
        }
    }
    document.getElementById("rotaContent").innerHTML = html;
}

// Back to Top Button
function handleScroll() {
    const backToTopBtn = document.querySelector('.back-to-top');
    if (window.scrollY > 200) {
        backToTopBtn.classList.add('visible');
    } else {
        backToTopBtn.classList.remove('visible');
    }
}

function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Day Navigation
function navigateDay(direction) {
    const daySelect = document.getElementById('daySelect');
    const currentIndex = daySelect.selectedIndex;
    const newIndex = currentIndex + direction;
    if (newIndex >= 0 && newIndex < availableDays.length) {
        daySelect.selectedIndex = newIndex;
        loadRota();
    }
}

// Auto Refresh
function startAutoRefresh() {
    // Clear any existing timers first
    if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer);
    }
    
    // Set up the auto-refresh timer to run every 5 minutes
    autoRefreshTimer = setInterval(() => {
        console.log("Auto-refreshing rota data...");
        preloadShifts(true); // Force refresh the data
    }, AUTO_REFRESH_INTERVAL);
    
    // Also refresh when the page regains focus
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            console.log("Page is visible again, refreshing data...");
            preloadShifts(true);
        }
    });
}

// Utility Functions
function forceReloadRota() {
    preloadShifts(true);
}

function clearRotaCache() {
    if (confirm("Clear cache and reload?")) {
        // Clear only event-specific cache
        localStorage.removeItem(`rotaCache_${currentEvent}`);
        localStorage.removeItem(`rotaCacheTimestamp_${currentEvent}`);
        localStorage.removeItem(`selectedDay_${currentEvent}`);
        location.reload();
    }
}

// Initialization
const originalOnload = window.onload;
window.onload = async function() {
    // Run original onload if it exists
    if (originalOnload) originalOnload();
    
    // Get event from URL and set up page
    currentEvent = getEventFromURL();
    updatePageHeader(currentEvent);
    
    // Set current year in copyright
    setCurrentYear();
    
    // Load shifts
    await preloadShifts();
    
    // Start auto-refresh
    startAutoRefresh();
    
    // Set up scroll event listener for back to top button
    window.addEventListener('scroll', handleScroll);
    
    // Setup touch and search handlers
    setupTouchHandlers();
    
    // Attach global click handler for name selection
    document.addEventListener('click', function(event) {
        const nameItem = event.target.closest('.search-name-item');
        if (nameItem) {
            event.preventDefault();
            event.stopPropagation();
            
            const name = nameItem.getAttribute('data-name') || 
                         nameItem.textContent.trim().split('\n')[0];
            handleNameSelection(name);
        }
    }, true);
};

</script>

</body>
</html>
